\documentclass[dvipsnames]{article}
\usepackage{markdown}
\usepackage{soulutf8}
%\renewcommand{\st}[1]{}
%\usepackage[scale=.75]{geometry}
\usepackage{placeins}
\usepackage{amsthm,amssymb,hyperref,marginnote}

\newtheorem{ex}{Example}[section]

\usepackage{subfig}

\usepackage[textsize=footnotesize]{luatodonotes}%\usepackage{todonotes}%
\usepackage{xcolor}
\newcommand{\nb}[1]{%
  \todo[color=blue!60!black,shadow]{NB:\\ #1}%
}

\usepackage{newunicodechar}
\input{UnicodeReplacements.tex}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\usepackage{amsmath}
% \usepackage[T1]{fontenc}
% \usepackage{lmodern}
%\usepackage[utf8]{inputenc}
\usepackage{xspace}
% macros
\newcommand{\tnote}[1]{
  \marginnote{\footnotesize #1}%
}
\newcommand{\rtnote}[1]{%
  \reversemarginpar%
  \tnote{#1}%
  \normalmarginpar%
}

\newcommand{\base}[1][ ]{%
  base ledger%
  \ifthenelse{\equal{#1}{ }}{}{#1}
}
\newcommand{\Base}[1][ ]{%
  Base ledger
  \ifthenelse{\equal{#1}{ }}{}{#1}
}

% \dag is defined to produce † unfortunately
\newcommand{\DAG}[1][]{\textsc{Dag}#1\xspace}
\newcommand{\Dag}[1][]{\textsc{dag}#1\xspace}

\newcommand{\fifo}{\textsc{fifo}}
\newcommand{\Fifo}{\textsc{Fifo}}
\newcommand{\aka}[1][]{a.k.a.\xspace}
\newcommand{\ie}[1][]{\emph{i.e.}, }
\newcommand{\eg}[1][]{\emph{e.g.}, }
\newcommand{\fig}[1][]{Fig.~}
\newcommand{\Learner}{%
  % the set of learners
  \ensuremath{L}
}
\newcommand{\Q}[1]{%
  % trust live
  Q_{#1}%
}
\newcommand{\rough}[1][ ]{%
  %\fbox{\color{blue!70!black}!!}%
  \ifthenelse{\equal{#1}{ }}%
  {{\color{red}{\bf!!}}}%
  {{\color{blue!70!black}\ul{#1}}}%
}
\newcommand{\circledX}[1]{\tikz[baseline={(x.south)}]{\node[circle,draw,inner sep=.3pt,outer sep=0pt,very thin](x){\tiny #1};}}
\usepackage{newunicodechar}
%\newunicodechar{}{\ensuremath{}}  
\newunicodechar{₁}{\ensuremath{{}_1}}
\newunicodechar{₂}{\ensuremath{{}_2}}
\newunicodechar{₃}{\ensuremath{{}_3}}
\newunicodechar{₄}{\ensuremath{{}_4}}
\newunicodechar{₅}{\ensuremath{{}_5}}
\newunicodechar{★}{\ensuremath{*}~}
\newunicodechar{ }{~}
%\newunicodechar{①}{\circledX 1}
\newunicodechar{“}{``}
\newunicodechar{”}{''}
%\newunicodechar{②}{\circledX 2}
\newunicodechar{ₐ}{\ensuremath{{}_a}}
\newunicodechar{ₚ}{\ensuremath{{}_p}}
\newunicodechar{‼}{\rough}
\newunicodechar{‽}{\ensuremath{?!}}
\newunicodechar{↑}{\ensuremath{\uparrow}}  
\newunicodechar{⇑}{\ensuremath{\Uparrow}}  
\newunicodechar{♯}{\ensuremath{\sharp%\hat\#
}}  
\newunicodechar{∅}{\ensuremath{\varnothing}}
\newunicodechar{≠}{\ensuremath{\neq}}              
\newunicodechar{∩}{\ensuremath{\cap}}              
\newunicodechar{≡}{\ensuremath{\equiv}}              
\newunicodechar{∈}{\ensuremath{\in}}
\newunicodechar{ℝ}{\ensuremath{\mathbb{R}}}
\newunicodechar{↔}{\ensuremath{\leftrightarrows}}    
\newunicodechar{→}{\ensuremath{\rightarrow}}
\newunicodechar{←}{\ensuremath{\leftarrow}}
\newunicodechar{⇒}{\ensuremath{\Rightarrow}}
\newunicodechar{∀}{\ensuremath{\forall}}
\newunicodechar{‌}{\allowbreak }
\newunicodechar{‍}{{}}                                

\usepackage{tikzpeople}%‼ for evil validators etc. 

\usepackage{tikz}
\usetikzlibrary{shapes,positioning,fit,backgrounds}
\usetikzlibrary{patterns,intersections,calc}
\newcommand{\qs}[1][~]{\tikz[baseline={([yshift=0pt]theNode.base)}]{\node[rectangle,
,double,inner sep=.5pt,outer sep=0pt,fill=black] (theNode){\textcolor{white}{\footnotesize \bf q#1}};}
}
\newcommand{\bk}[1][green!60!black]{\tikz[baseline={([yshift=0pt]theNode.base)}]{\node[regular polygon, regular polygon sides=6
,double,inner sep=.5pt,outer sep=0pt,fill=#1] (theNode){\textcolor{white}{\footnotesize \bf bk}};}}
\newcommand{\ac}{\tikz[baseline={([yshift=0pt]theNode.base)}]{\node[regular polygon, regular polygon sides=6
,double,inner sep=.5pt,outer sep=0pt,fill=black] (theNode){\textcolor{white}{\footnotesize \bf a}};}}

\newcommand{\hd}[1][ ]{%
  \ifthenelse{\equal{#1}{}}%
  {\tikz[baseline={([yshift=0pt]theNode.base)}]{
      \node[rectangle,inner sep=1.5pt,outer sep=0pt,double] (theNode){\textcolor{black}{\footnotesize \bf \ul{HD}}};
    }}%
  {\tikz[baseline={([yshift=0pt]theNode.base)}]{
      \node[rectangle,double,inner sep=1.5pt,outer sep=0pt,double,draw] (theNode){\textcolor{black}{\footnotesize \bf HD}};
      
    }}%
}
\newcommand{\wh}[1][ ]{%
  \tikz[baseline={([yshift=0pt]theNode.base)}]{%
    \ifthenelse{\equal{#1}{ }}%
    {\node[rectangle,fill=black,inner sep=1.5pt,outer sep=0pt] (theNode){\textcolor{white}{\footnotesize \bf WH}};}%
    {\node[rectangle,draw,fill=lightgray,inner sep=1.5pt,outer sep=0pt] (theNode){\textcolor{black}{\footnotesize  WH}};}%
  }%
}

\newcommand{\anItemInline}[6][theNode]{%
  % #1 the name of the node (just in case, remember picture is on)
  % #2 shape (e.g., ellipse)
  % #3 fill color (e.g., black)
  % #4 draw color (e.g., green, or none)
  % #5 text color (e.g., white)
  % #6 the actual text (e.g., \bf TX)
  \tikz[baseline={([yshift=0pt]#1.base)},remember picture]{%
    \node[#2,fill=#3,draw=#4,inner sep=.5pt,outer sep=0pt] %
    (#1){%
      \textcolor{#5}{%
        \footnotesize #6%
      }%
    };%
  }%
  % additional “decorations” via another pic, 
  % (with `remember picture` and `overlay`)
}

\newcommand{\tx}[1][theTX]{%
  \anItemInline[#1]%
  {ellipse}%
  {black}%
  {none}%
  {white}%
  {\bf TX}%
}
% \newcommand{\tx}[1][]{%
%   \tikz[baseline={([yshift=0pt]theNode.base)}]{%
%     \node[ellipse,fill=black,inner sep=.5pt,outer sep=0pt] %
%     (theNode){%
%       \textcolor{white}{\footnotesize \bf TX\makebox[0pt][l]{\ensuremath{{}_{#1}}}}};%
%   }%
% }
\newcommand{\es}{\tikz[baseline={([yshift=0pt]theNode.base)}]{\node[ellipse,fill=white,draw,thick,inner sep=.5pt,outer sep=0pt] (theNode){\textcolor{black}{\footnotesize TX}};}}
\newcommand{\rnd}{\ensuremath{\mathrm{rnd}}}
\newcommand{\cnt}{\ensuremath{\mathrm{cnt}}}
% \usepackage{ebgaramond}
% \usepackage[cmintegrals,cmbraces]{newtxmath}
% \usepackage{ebgaramond-maths}
% \usepackage{amssymb}
\usepackage{fontspec}
% \setmainfont{Asana-Math}

%https://tex.stackexchange.com/questions/425098/which-opentype-math-fonts-are-available
\usepackage{comment}
%\includecomment{comment}

\title{%
  Heterogeneous Narwhal: % 
  \\
  a multi-chain mempool \Dag%
}
\author{Typhon Team Heliax}
\date{\today}

\newcommand{\code}[2][ ]{%
  \makebox[0pt][r]{\tiny%
    \href{%
      https://github.com/anoma/typhon/tree/hnarwhal-stateright/hn-stateright/heterogeneous_narwhal%
    }%
    {\color{gray}\texttt{#2}}%
    ~~%
  }%
}
%\renewcommand{\todo}[2][]{}
%\renewcommand{\endnote}[1]{#1}
\usepackage{enotez}
\setenotez{counter-format=Alph}
\let\oldendnote\endnote
\renewcommand{\endnote}[2][ ]{%
  \ifthenelse{\equal{#1}{ }}%
  {\marginnote{\oldendnote{#2}}}%
  {\marginnote{\oldendnote[#1]{#2}}}%
}
\newcommand{\hn}{Heterogeneous Narwhal\xspace}
\begin{document}
%\begin{comment}


\begin{center}
  \huge %
  notes to prospective co-authors, %
  colleagues, and friends %
\end{center}
\label{page:firstpage}
\todo[inline,caption={},color=blue!30!white]{%
  Please note the following about this paper:
  \begin{itemize}
  \item it is “merely” a technical report about
    \emph{Heterogeneous Narwhal}
  \item a “reader's digest” version should follow 
  \item it is the \emph{basis} for chimera chains;
  \item however chimera chains, will be left as (concurrent) future work;
  \end{itemize}
  Please keep this in mind,
  when reading the paper!
}

\todo[inline,caption={},color=green!30!white]{%
  paper plan:\\
  \begin{itemize}
  \item “review” learner graph
  \item “review” basic narwhal
  \item
    go for the real deal: %
    we go for an “ideal” world
    where in principle 
    every validator 
    \begin{enumerate}
    \item could have (part of) all transaction data available
    \item participate in as many differently colored ledgers as desired
    \end{enumerate}
    this goal is independent of the specific uses of the different chains,
    cf. chimera chains
  \item %
    description of the %
    \href{https://github.com/anoma/typhon/tree/hnarwhal-stateright}%
    {prototype implementation}
  \end{itemize}
  \begin{description}
  \item[learner graph] %
    There are several ways to understand the learner graph:
    \begin{itemize}
    \item 
      \emph{learner-crafted} learner graphs,
      where learners are formalizing they assumption about
      \begin{enumerate}
      \item tolerated bad behavior
      \item expected good behavior
      \end{enumerate}
      alternatively,
      on may assume and omniscient observer,
      which hands out the learner graph to the consensus designer
    \item
      \emph{observed} learner graphs,
      typically generated by validators
      to keep track of what they have seen;
      each observation gives rise
      to maximally optimistic learner graphs:
      every validator is supposed to behave well
      unless evidence of misbehaviour/attacks 
      have been found.
      For each incident,
      one might actually ask for “resolution”,
      either investigating an attack
      or admitted misbehavior (typically due to bugs)
    \end{itemize}
  \end{description}
}
\clearpage\cleardoublepage

\maketitle

\begin{abstract}
  \noindent
  Blockchains exhibit \emph{linear} structure, 
  resulting from a \emph{single} reference to the previous block.
  If instead, 
  each block may reference \emph{several} previous blocks,
  we can build a \emph{directed acyclic graph} (\Dag) of blocks.
  In fact,
  such “block \Dag[s]” are the basic data structure that
  several recent consensus algorithms rely on,
  \eg \Dag-rider, Bullshark, and Narwhal\&Tusk.\footnote{%
    The respective references are, 
  }
  These protocols build 
  a growing “global” \Dag of transaction data such that%
  ---among other things---%
  ① every validator's local view is a sub-\Dag of the “global” \Dag and %
  ② every node of the “global” \Dag is
  “logged”\endnote{%
    Logging is terminology borrowed from César Sanchez:
    he likes to talk about \emph{log-chain}s,
    or more verbose “mempool \emph{log system}”
    cite \href{https://arxiv.org/abs/2206.11845}{%
    Setchain: Improving Blockchain Scalability
    with Byzantine Distributed Sets and Barriers}
  }
  for inclusion into a total order of blocks. 
  Such “global” \Dag[s] will be the topic of the present paper, 
  referred to as {Mempool \Dag[s]}, or \emph{mem-\slshape\Dag[s]}, 
  for short.  

  The paper introduces a multi-ledger mem-\Dag, 
  generalizing Narwhal's single ledger mem-\Dag;
  in analogy to Heterogeneous Paxos,
  the new protocol is called \emph{Heterogenous Narwhal}.   
  In principle,
  Heterogeneous Narwhal\&Paxos are an alternative for bridges. 
  \todo[caption={}]{%
    In a follow up paper,
    we actually need to explain how heterogeneous Narwhal is \\
    1. an alternative to bridges    \\
    2. which benefits / drawback we have, in general\\
    3. which parts are “implementation detail”.\\
    so, as written on the opening page (on page~\pageref{page:firstpage}):
    not in this paper ... 
  }
  However,
  in the present paper,
  we focus on \emph{eventual finality} of the mem-\Dag[s].
\end{abstract}




\tableofcontents
\section{Introduction}

\todo[inline]{main contribs:\\[\baselineskip]
  \begin{minipage}{1.0\linewidth}
    - alternative to bridges (between very different chains ?)\\
    - merging might be actually a very good thing (for very small chains)\\ 
    - chimera chains (between big chains)
  \end{minipage}\\[\baselineskip]
  In summary,
  we present a general framwork for building
  a cross-chain ecosystem of pre-existing and new ledgers.  
}

\section{Context}
\label{sec:context}
\todo[inline]{.. a little bit of story telling}

We want to work towards a multi-chain world in 
which 
- everyone can interact with all chains of the ecosystems
- there is a unique definitive state of every chain 





\section{Preliminaries}
\label{sec:preliminaries}
\todo[inline]{%
  ``copy'' relevant parts of % 
  the heterogeneous paxos tech report%
}

Let us fix an arbitrary learner graph. 

\begin{definition}[Global Weak Quorum]
  \label{def:global-weak-quorum}
  A %
  \emph{global weak quorum} %
  is a set~\(X\) that is a weak quorum for each learner,  %
  i.e., \(X ∩ qₐ ≠ ∅\) %
  for every learner~\(a ∈ \Learner\), and %
  all \(qₐ ∈ \Q{a}\).
\end{definition}

\begin{definition}[Universal Quorum]
  \label{def:universal-quorum}
  A universal quorum is a set
  that contains a qourum for each learner. 
\end{definition}
\todo{%
“upward” closure for live quorums seems a “wrong” assumption
}

\section{Overview: %
  mem-DAGs, heterogeneity, etc.
}
\label{sec:overview}
Recall that mem-\Dag protocols build a “global” \Dag of blocks,
each referencing a quorum of previous blocks;
the term global is used mainly informally,
since it is from the point of view of a
fictive omniscient observer
that sees all blocks that some validator has proposed.
While being not available to any single agent,
the global \dag is of intersubjective relevance,
as every \emph{local} view of any validator
is a sub-graph of the “global” \Dag. 

A block in the \Dag can be \emph{committed} 
using an arbitrary consensus algorithm
if it is referenced by a weak quorum 
(from the next “layer” in the \Dag)
in every local view of the consensus participants.

An example of such a “global” \Dag
is shown in \fig\ref{fig:blue_dag}. 
In the present paper,
we describe a protocol for concurrent building 
of \emph{entangled} \Dag[s] for a whole ecosystem of different ledgers,
in the spirit of a multi-chain world. 

\begin{figure}[htb]
  \centering
  \includegraphics[width=.95\linewidth]{./blue_dag.png}
  \caption{A mem-\Dag (self-references omitted)}
  \label{fig:blue_dag}
\end{figure}


\begin{figure}[htb]
  \centering
  \begin{tikzpicture}
    \node[draw] (avl) {transaction data};

    \node[draw,right=1ex of avl] (dag) {``causal'' \Dag structure};
    \begin{pgfonlayer}{background}
    \node (x) [fill=lightgray,fit=(avl)(dag)] {};
  \end{pgfonlayer}
  \node[above=2ex of x,draw,double] {uniqueness of headers};
\end{tikzpicture}\makebox[0pt][r]{\Large \bf \color{blue} make this Fig. something that actually helps (or delete)} \protect\todo{where to put the signed quorums ?!}
  \caption%
  [Interdependence of availability and integrity]%
  {Illustration of 
    the interdependence of the availability and 
    integrity protocols}
  \label{fig:availability-n-integrity}
\end{figure}



Roughly, we have two complementary protocols running concurrently: 
 \begin{enumerate}
 \item the availability protocol; and
 \item the integrity protocol. 
 \end{enumerate}
 The availability protocol makes sure
 that transaction data is available 
 as long as necessary;\footnote{%
   There is some fine print concerning 
   the conditions under which this is actually the case. 
 }
 moreover,
 the availability protocol 
 is tasked with keeping available 
 the \emph{signed headers},
 \todo{explain \texttt{signed headers}}
 which the integrity protocol produces. 

 The integrity protocol makes sure that 
 each validator can only produce one block in each of its (local) rounds. 


 

\section{Architecture and communication patterns}
\label{sec:communication-patterns}
 We incorporate Narwhal's~\cite{NT} 
 scale out architecture%in our availability protocol 
 : %
 each validator has a unique \emph{primary} and % 
 a number of \emph{workers} % 
 (see \fig\ref{fig:validators})%
 . 
\begin{figure}[htb]
  \centering

validator:\(\left\{\begin{tikzpicture}[baseline={(p.south)},remember picture]
    \node[circle,draw,inner sep=1.5ex] (p) at (5.5,1.2) {p};
    \foreach \i in {1,...,10}{
      \coordinate (p_\i) at  (p.160+20*\i);
    }
    \foreach \i in {1,...,10}{
      \node[rectangle,fill=lightgray](w_\i) at (\i,0){\(w_{\i}\)};
      \draw[->] (w_\i.north) .. controls +(0,.2) .. (p_\i);
    }
    \begin{pgfonlayer}{background}
      \node[rounded corners,fill=blue!30!white,inner sep=2ex] (background) [fit=(w_1.south west)(w_10.south east)(p)] {};
    \end{pgfonlayer}
  \end{tikzpicture}\right.\)

\vspace{4ex}

\tikz[remember picture]{\node[rectangle,fill=gray,draw] (c) {client};}\hfill~\\

\vspace{4ex}

validator:\(\left\{\begin{tikzpicture}[baseline={(q.north)},remember picture,yscale=-1]
    \node[circle,draw,inner sep=1.5ex] (q) at (5.5,1.2) {q};
    \foreach \i in {1,...,10}{
      \coordinate (q_\i) at  (q.200-20*\i);
    }
    \foreach \i in {1,...,10}{
      \node[rectangle,fill=lightgray](v_\i) at (\i,0){\(v_{\i}\)};
      \draw[->] (v_\i.south) .. controls +(0,.2) .. (q_\i);
    }
    \begin{pgfonlayer}{background}
      \node[rounded corners,fill=blue!30!white,inner sep=2ex] (background) [fit=(v_1.north west)(v_10.north east)(q)] {};
    \end{pgfonlayer}
    % --------------------------------------------------------------------------------
    \begin{scope}[overlay,thick]
          \foreach \j in {1,...,10}
    \draw[<->] (v_\j) -- (w_\j);

    \draw[<->] (c.-15) .. controls +(2,0) and +(-1,-1) .. (v_3.north west);
    \draw[<->] (c.15) .. controls +(2,0) and +(-1,1).. (w_7.south west);
    \draw[<->] (p) -- (q);
    \end{scope}
  \end{tikzpicture}\right.\)
  \caption{The structure and communication patterns of validators}
  \label{fig:validators}
\end{figure}




\section{Worker actions}
\label{sec:worker-actions}
Every validator has the same number of workers. 
Thus,
each worker can be assigned a unique \emph{mirror worker} 
on every other validator.
We shall adopt the convention 
that mirror worker identifiers share the same subscript.
For example,
in \fig\ref{fig:validators},
workers~\(w_2\) and~\(v_2\) are mirror workers of each other.
In the integrity protocol,
workers are only tasked with “bookkeeping” matters; 
in particular,
they keep track of (batches of) transactions,
their hashes,
and erasure coding shares;
they only pass on hashed data and 
block header information to their primaries.
The idea is to keep the network bandwidth usage of primaries 
as low as possible. 
In particular,
primaries never send messages or any other signals to their workers,
\todo[inline]{EXCEPT FOR}
\endnote{%
  Sharing the round number is the point where
  one might be tempted to deviate from this concept. 
}

\subsection{The pure availability protocol: worker actions}
\label{sec:base-protocol}
\todo[inline]{%
  get rid of the broadcast of the availability certificates%
  % ???
  \tiny
  \sf
  TH well, cannot make sense of that myself any more 
  instead we broadcast signatures of headers ?
  % ?? 
  or was that an error inf the figure
  \emph{The integrity protocol (concluding each round that’s was “opened” in
the availability-protocol)}
}
\todo[inline]{%
  maybe we need to ``announce'' headers, % 
  to avoid ``crossing'' of round numbers of learner%
}
\todo[inline]{%
  so, signed qourums are an ``output'' of the integrity protocol,
  and need to be made available (such that it is possible to create new headers). 
}

\todo[inline]{%
  worker hashes also should include an availability certificate %
  of the header creator's previous header %
}

\begin{description}
\item[%
  \code{MessageEnum::TxReq}%
  Transaction collection (\tx{}←)%
  ] 
  \tnote{worker\\ ← client}
  \todo{in the typhon sources for \texttt{`heterogeneous\_narwhal`},
    each transaction collection is \emph{immediately} followed 
    by a \texttt{TxAck}
  }
  Each worker keeps listening 
  for incoming transaction requests from clients.\footnote{%
    The bandwith and amount of storage for storing incoming transactions
    \emph{should} be big enough 
    to process all incoming transactions. 
    We share this assumption with Byzantine set consensus \cite{RedBelly}. 
    Transaction fees are one way to avoid flooding attacks,
    making the latter prohibitively expensive. 
    For example,
    we might assume a \fifo-buffer
    although it is more likely
    a priority queue,
    based on a combination of fees and
    quality of service considerations. 
  }
  Transactions should be buffered using reasonably fast memory. 
  \endnote{%
    The matter of reasonably fast transaction buffer
    needs additional context, 
    in particular details from the \textsc{p2p} layer. 
  }
  \todo[inline,color=SkyBlue]{%
    In the
    \href{https://github.com/anoma/typhon/tree/hnarwhal-stateright/hn-stateright/heterogeneous_narwhal}%
    {code}, 
    we instantly acknowledge the transactions received.
    \\
    \code{MessageEnum::TxAck}
  }
 
\item[%
  Transaction distribution (\tx⇒)%
  ]
  \tnote{worker\\ ⇒ worker}
  Each worker “broadcasts” erasure coding shares of 
  every received transaction to mirror workers.
  In the simplest case\xspace% 
  ---the one we cover first---%
  this amounts to broadcasting the transaction.\footnote{ 
  However, 
  if we perform proper erasure coding,  
  it is not broadcasting in the strict sense:
  each mirror worker receives a different message. 
  We first cover the case of trivial erasure coding
  ‼[covering the case of proper erasure codining in ‽].
  }
  In general,
  transaction distribution can be divided into two steps.
  \todo[inline]{
    we might require a 
    \emph{position number} for
    transactions of the current batch, 
    and a sequence number (of the block to be produced)
  }
  \begin{description}
  \item[Erasure coding via copying (\es)]
    \tnote{[worker]}
    We first cover the case of trivial erasure coding, 
    in line with the description of the homogeneous case~\cite{NT}. %
    Thus, erasure coding shares of a transactions are simply copies. 
    We visually distinguish between “copies” of transactions
    from the “original” transaction supplied by the client,  
    using the symbols \tx\ and \es, respectively. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \todo[inline]{put fwd ref / future work }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
  \item[%
    \code{MessageEnum::TxToAll}%
    Copy distribution (\es⇒)] 
    \tnote{worker\\ ⇒ worker }
    Each share of the erasure code,
    \ie a copy of the transaction, 
    is sent to every mirror worker.%
    \endnote{
      elaborate on the distribution scheme,
      and how the destination of each earasure share is determined
      (for the general erasure coding).
    }%
    \xspace
    We tag each transaction with a \emph{sequence number},
    \todo[color=red]{%
      YIKES !!!\\
      how do we know the validators round number? \\
      well, we \textsc{don't}
    }
    \todo[color=SkyBlue]{%
      as a solution,
      we introduce the \emph{take},
      which might be increasing faster than the round number
    }
    consisting of the validator round and 
    the position in the list of transactions for 
    the next block (header) in which the transaction will be included. 
    % so that it becomes clear in which order the 
    % transactions of the next block (header) will be listed. 
    
  \item[%
   \code{fn process\_tx\_req}%
   Transaction copy (erasure code) \colorbox{SkyBlue}{reception}%
   ]\tnote{[worker]}%
   Upon receiving a transaction copy
    (the specific form of erasure code, we are using)
    we store a copy locally. 
    
    
  \end{description}
  Note that copies of transactions are \emph{not} signed by the worker. 
  Signatures are deferred to until after the last transaction  
  of a validator round, 
  when the worker will sign the hash of the list of all broadcast transactions,
  called a \emph{worker hash}. 


  
\item[Worker hash compilation (\wh)]
  \tnote{(worker)}
  Towards the end of a “validator round”,\endnote{%
    Is there any such thing as “validator round”?\\
    - sequence number\\
    - validator height\\
    - ... 
  }%
  \todo[inline,color=red,caption={}]{%
    here now, we need to
    \begin{enumerate}
    \item introduce signals from primary to workers,
    \item replace the round number by a “take” based mechanism
    \end{enumerate}
  }
  \xspace
  each worker produces its worker hash for the broadcast batch of transactions. 
  In detail,
  a worker hash consists of 
  \begin{itemize}
  \item the hash of the broadcast list of transactions,
  \item the number of transactions, and
  \item the \st{round number}\ul{take}, 
    \todo[color=SkyBlue]{%
      very much like in a movie,
      we piece together each header form \textsc{take},
      or any other single word for \emph{batch number}
      }
  \end{itemize}
  signed by the worker. 
  \endnote{\color{red}
    For general erasure coding:
    \em Does this need to includes for each receiving worker,
    the (hashes of the) erasure coding shares that 
    they should have available. ?
  }
\item[%
  \code{MessageEnum::WorkerHx}%
  Worker hash provision (\wh↑)%
  ]
  \tnote{worker\\ → primary}
  The most recent worker hash is sent to the primary 
  for inclusion into the next header. 
  \todo{
    How much “additional” information do we have 
    to include into the header
    such that signing a header certificate becomes meaningful?
  }

\item[%
  \code{MessageEnum::WHxToAll}%
  Worker hash broadcast (\wh⇒)%
  ] 
  \tnote{worker\\ ⇒ worker }  
  A worker broadcasts its most recent worker hash
  to mirror workers.

\item[%
  \code{fn process\_w\_hx}%
  Worker hash reception and checking ({\wh[]←})%
  ]%
  \tnote{%
    worker\\%
    ← worker%
  }
  At any time, 
  a worker can receive a worker hash 
  from a mirror worker. 
  As a first reaction, 
  it checks whether enough
  transactions have been received by the worker and, 
  if so, 
  whether the hash of the list of transaction matches the worker hash. 

\item[%
  \code{MessageEnum::WHxFwd}%
  Worker hash forwarding ({\wh[]⇑})%
  ]
  \tnote{worker\\ → primary}  
  If a worker has successfully checked 
  the availability of the transactions of a received worker hash, %
  it “forwards” the worker hash to its primary.\footnote{%
    Validators will use this information 
    to send availability commitments to block headers of other primaries.
  }
\end{description}



\begin{figure}[htb]
  \centering
  \tikzstyle{every node}+=[outer sep=0pt,inner sep=1pt]
  \newcommand{\primaryDistance}{15ex}
  \newcommand{\workerPrimaryDistance}{1ex}
  \newcommand{\workerDistance}{3ex}
  \scalebox{.9}{%
  \footnotesize%
  \begin{tikzpicture}[scale=1.2]
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % The message passing diagram of the availability protocol at genesis
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % first the time lines for primaries and their workers
    \coordinate (primaryAnchor) at (0,0);
    \foreach \p in {1,...,5} {
      \node[below=\primaryDistance of primaryAnchor,anchor=east] (p\p) 
      at (primaryAnchor) {\ensuremath{\text{primary}_\p}};
      \draw[->] (p\p) -- ++(10.4,0);
      \coordinate (workerAnchor) at ([yshift=-\workerPrimaryDistance]p\p.east);
      \foreach \j in {1,...,2} {
        \node[below=\workerDistance of primaryAnchor,anchor=east] (w\p_\j) 
        at (workerAnchor) {\ensuremath{\text{worker}_{\p,\j}}};
        \draw[->,draw=lightgray,semithick] (w\p_\j) -- ++(10.4,0) ;
        \coordinate (workerAnchor) at (w\p_\j.east);
      }
      \coordinate (primaryAnchor) at (p\p.east);
    }
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % a first transaction tx1
    \node (tx1) at ([xshift=3.5ex]w1_1.east) {\tx₁};
    \draw[->,double,dotted,shorten >=-2ex] (tx1.200) ++ (200:1em) -- (tx1);
    \foreach \p in {2,...,5} {
      \node (es\p_1) at ([xshift=6ex-\p ex]tx1|-w\p_1) {\es₁};
      \draw[->] (tx1) -- (es\p_1) ;
    }
    % a bunch of transactions tx2-5 that will make it into WHs actually
    \node (tx2) at ([xshift=3*3.5ex]w3_2.east) {\tx₂};
    \draw[->,double,dotted,shorten >=-2ex] (tx2.200) ++ (200:1em) -- (tx2);
    \foreach \p in {1,2,4,5} {
      \node (es\p_2) at ([xshift=6ex-\p ex]tx2|-w\p_2) {\es₂};
      \draw[->] (tx2) -- (es\p_2) ;
    }
    \node (tx3) at ([xshift=5*3.5ex]w3_2.east) {\tx₃};
    \draw[->,double,dotted,shorten >=-2ex] (tx3.200) ++ (200:1em) -- (tx3);
    \foreach \p in {1,2,4,5} {
      \node (es\p_3) at ([xshift=6ex-\p ex]tx3|-w\p_2) {\es₃};
      \draw[->] (tx3) -- (es\p_3) ;
    }
    \node (tx4) at ([xshift=7*3.5ex]w3_1.east) {\tx₄};
    \draw[->,double,dotted,shorten >=-2ex] (tx4.200) ++ (200:1em) -- (tx4);
    \foreach \p in {1,2,4,5} {
      \node (es\p_4) at ([xshift=6ex-\p ex]tx4|-w\p_1) {\es₄};
      \draw[->] (tx4) -- (es\p_4) ;
    }
    \node (tx5) at ([xshift=9*3.5ex]w3_1.east) {\tx₅};
    \draw[->,double,dotted,shorten >=-2ex] (tx5.200) ++ (200:1em) -- (tx5);
    \foreach \p in {1,2,4,5} {
      \node (es\p_5) at ([xshift=6ex-\p ex]tx5|-w\p_1) {\es₅};
      \draw[->] (tx5) -- (es\p_5) ;
    }
    % collection of txs into worker hashes wh1 and wh2
    \node[right=.1ex of tx5] (wh1) {\wh₁};
    \draw[dotted,bend right=2.5ex] (wh1.center) to (tx5.center);
    \draw[dotted,bend right=5ex] (wh1.center) to (tx4.center);
    \node[right=3.5ex of wh1|-tx3] (wh2) {\wh₂};
    \draw[dotted,bend left=2.5ex] (wh2.center) to (tx3.center);
    \draw[dotted,bend left=5ex] (wh2.center) to (tx2.center);
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % "upload" of worker hashes wh1 and wh2 to the primary, wh1' and wh2'
    \node (wh1') at ([xshift=-2ex]wh2|-p3) {\wh₁};
    \draw[->] (wh1) -- (wh1');
    \node[right=0ex of wh1'] (wh2') {\wh₂};
    \draw[->] (wh2) -- (wh2');
    % the following should be much later, but ... (unique harmless hack)
    \node[right=1ex of wh2',fill=white] (hd3) {\hd};
    \foreach \k in {1,2}
    \draw[dotted,bend right=9ex-3*\k ex] (hd3) to (wh\k'.center);
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % dissemination of worker hashes wh1 and wh2
    \foreach \p in {1,2,4,5} {
      \node (wh1_\p_1) at ([xshift=3ex-\p ex]wh1'|-w\p_1) {\wh[]₁};
      \draw[->] (wh1) -- (wh1_\p_1) ;
    }
    \foreach \p in {1,2,4,5} {
      \node (wh2_\p_2) at ([xshift=6ex-\p ex]wh2'|-w\p_2) {\wh[]₂};
      \draw[->] (wh2) -- (wh2_\p_2) ;
    }
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % worker hash upload at receiving validators
    \foreach \whx in {1,2} { % for each of the two worker hashes
      \foreach \p in {1,2,4,5} { % for each "other" validator
        \node (wh\whx_\p_\whx') at ([xshift=4ex-\whx ex]wh\whx_\p_\whx|-p\p) {\wh[]\ensuremath{{}_\whx}};
        \draw[->] (wh\whx_\p_\whx) -- (wh\whx_\p_\whx');
        % and header creation (after second block)
        % ... and sending availability votes
        \ifthenelse{\equal{\whx}{2}}%
        {\node[right=2ex of wh\whx_\p_\whx',fill=white,draw=none] (hd\p) {\hd}; 
          \foreach \k in {1,2}
          \draw[dotted,bend right=9ex-3*\k ex] (hd\p) to (wh\k_\p_\k'.center);
        }%
        {}%
      }
    }
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % collect "foreign" whs into availability votes for a block
    \coordinate (ac) at ([xshift=2ex,yshift=2ex]hd1|-p3);
    \foreach \p in {1,2,4} { % for each "other" validator
      \node[fill=white] (av\p) at (ac){\hd\makebox[0pt][l]{\ensuremath{{}_{\sim\p}}}};
      \coordinate (ac) at ([xshift=-1ex,yshift=-1ex]ac);
    }
    \foreach \p in {1,2,4} { % for each "other" validator
      \draw[->] (hd\p) -- (av\p.east);
      \draw[ultra thick,red,double,->] (hd3) --node[auto]{trigger} (hd\p);
    }
    \draw[ultra thick,red,double,->] (hd3) --node[auto]{trigger} (hd5);
    \node[fill=white] (av3) at (ac){\hd\makebox[0pt][l]{\ensuremath{{}_{\sim3}}}};
    \draw[->] (hd3) -- (av3);
    \begin{pgfonlayer}{background}
      \node[fit={(av3)(av1)([xshift=2ex]av1.north east)},fill=lightgray] (ac3) {};
    \end{pgfonlayer}
    % broadcast the availability certificate
    \foreach \p in {1,...,5} { % for each "other" validator
      \node (ac\p') at ([xshift=17ex-\p ex]ac|-p\p) {\ac\ensuremath{{}_\p}};
      \draw[->] ([yshift=2.5ex-\p ex]ac3.east) -- (ac\p'); 
    }
  \end{tikzpicture}%
  }
  \caption{The availability protocol in the genesis round}
  \label{fig:availability-protocol}
\end{figure}
\todo[caption={}]{%
  concerning ``triggering'' the header construction, 
  there are the following points
  \\
  1. when a the triggering signing request is \emph{received} by a primary,
  we might need to ``wait'' for the corresponding worker hashes
  \\
  2. new signing for more recent rounds make old ones obsolete
  \\
  3. what are the incentives for speedy signing ?
}\endnote{%
  On speedy signing incentives:
  \begin{itemize}
  \item as a validator, I want primarily \emph{my} blocks signed
  \item 
    So, why should I sign \emph{your} header?!
    \begin{itemize}
    \item It comes even with the storage commitment for my workers!
    \item Actually, if “everybody” else is signing, I am still gonna be fine !!!
    \end{itemize}

    Thus, having a signature as part of an availability certificate should give
    some kind of reward!
  \end{itemize}
  On the other hand,
  it is natural to collect signatures for the availability certificate
  on a “first come, first served” basis
}

%\end{comment}
\section{Primary actions}

\subsection{Availability at genesis}
The pure availability protocol: genesis actions

\begin{description}
\item[Genesis header compilation ({\hd[]})] 
  \tnote{[primary]}
  If a primary has obtained a “complete set”
  \todo{
    \emph{“complete set”}
    is an undefined term, right?
    }%
    of 
  worker hashes for the genesis round
  from its workers, 
  it can compile a block header. 
  Compiling worker hashes into headers
  works the same for worker hashes of local workers
  and those generated from transactions received at other validators.%
  \footnote{%
    However, 
    the compiled worker hashes will have different roles,
    depending on whether they are stemming from local workers or not. 
    In particular,
    primaries will only need to generate 
    certificates of availability for “local” headers.
  }
  At genesis,
  each header consists of
  \begin{itemize}
  \item the creator's identity and
  \item and the list of worker hashes.
  \end{itemize}
  \begin{description}
  \item[Header announcement / Signature request]
    A primary announces the next \emph{header}
    by sending information about
    \begin{itemize}
    \item information about which worker hashes to be included
      (as pairs of worker-ids and take numbers)
    \item the round number
    \end{itemize}
    \todo[inline]{it is, isn't it?}
    .
    
  \item[Header collection]
    The primary has to collect 

  \end{description}
 

  
\item[Availability voting/commitment (\hdₚ→)]
  \tnote{primary\\ → primary}
  A genesis header of a primary is acceptable 
  if all its worker hashes have been forwarded
  by the local workers
  (which are trusted to have checked these worker hashes).
  The latter implies that the relevant erasure coding shares
  are kept available. 
  An availability commitment is made
  by signing the header 
  and sending the signed header to the creator
  (for the purpose of aggregation into availability certificates). 

\item[Commitment aggregation (\hdₚ←)]
  \tnote{[primary]}
  The signatures of received availability commitments 
  are aggregated into certificates of availability 
  for a header. 

\item[Certificate broadcast (\ac⇒)]
  \tnote{primary\\ ⇒ primary}
  Once a primary receives commitments
  from a global weak quorum for its genesis header,
  it broadcasts the certificate of availability.  

\item[optional header distribution] 
  ~\todo[inline]{%
    Right now,
    there seems no reason to add this ``safe guard'';
    it might be confusing.
  }
  One might expect that header creators send their headers around.
  However,
  there is no need for this.%
  \endnote{... at least in theory, we'll keep it slick for the moment} 
  
  % has uploaded a worker hash 
  % for the genesis round, 
  % optionally, 
  % the primary \emph{can} distribute 
  % the genesis header:
  % ‼{\color{red} why do we do this then at all?}
  % \begin{itemize}
  % \item the primary~\(p\)
  % \item worker hashes \(\wh_1 \cdots \wh_n\), 
  %   produces by the local workers at \(p\)'s validator. 
  % \end{itemize}
  % In theory,
  % this step is not necessary,
  % since each other primary will eventually receive
  % the  worker hashes \(\wh_1 \cdots \wh_n\),  
  % forwarded from it's workers. 
  
  % Note,
  % the creating primary of the header does not sign it;
  % the signature is “delayed” until 
  % enough primaries have commited to storing 
  % the underlying data,
  % as described by the next action.

  % ‼[a “sequence number” with the set of “target” learners should suffice,
  % to trigger such an header request]
\end{description}

A (partial) execution of the availability protocol at genesis is
illustrated in \fig\ref{fig:availability-protocol}.

\FloatBarrier

\subsection{Integrity: the general case at once}
First off,
the integrity-protocol
re-uses the sending of signed headers~\(\hdₚ\) to the creator 
(from the availability-protocol), 
as a commitment of the signer to 
one unique header for the  validator (and round),  
namely the first one signed and sent. 
Thus, 
correct validators will not sign and send any other header 
for the respective  creator of the header (for the same round). 


\begin{description}
\item[Integrity signing \(\hdₚ\)]
  \tnote{primary ⇒ primary}
  Signing and sending the header to the creator implies that 
  (a correct) primary will not sign any other header
  of the same creator with the same round number. 

\item[Block aggregation (\bk)]
  \tnote{[primary]}
  Using 
  the same signature aggregation mechanism that
  is used for availability certificates, 
  validators will aggregate additional signatures 
  (besides the availability signature) for their block headers,
  producing learner-specific \emph{blocks}, 
  which, by definition, 
  are headers signed by a learner-specific quorum. 

\item[Block broadcast \(\bk\)] 
  \tnote{primary ⇒ primary}
  The aggregated signatures of a block header form 
  a \emph{learner-specific block}. 
  The signature aggreator will broadcast 
  to all primaries that belong to some quorum of the respective learner. 
  (Later,
  these will be used as references to 
  previous blocks in the learner-specific \Dag[s]
  see \ref{???}) %FIXME reference.
\end{description}

There is no conceptual difference between 
the integrity protocol at genesis,
comparted to the typical case. 
The only difference is that 
headers in the general case 
will carry additional information. 
Thus,
we can finish the description of the protocol, 
by filling in the additional data and steps in the typical phase
of the availability-protocol 
(see also \fig\ref{fig:data-structures},
for the difference between headers at genesis and the typical phase). 

\begin{figure}[htb]
  \centering
  \tikzstyle{every node}+=[outer sep=0pt,inner sep=1pt]
  \newcommand{\primaryDistance}{15ex}
  \newcommand{\workerPrimaryDistance}{1ex}
  \newcommand{\workerDistance}{3ex}
  \scalebox{.8}{%
    \footnotesize%
    \begin{tikzpicture}[scale=1,thick]
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      % The message passing diagram of the integrity protocol
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      \coordinate (primaryAnchor) at (0,0);
      \foreach \p in {1,...,7} {
        \node[below=\primaryDistance of primaryAnchor,anchor=east] (p\p) 
        at (primaryAnchor) {\ensuremath{\text{primary}_\p}};
        \draw[->] (p\p) -- ++(15,0);
        \coordinate (primaryAnchor) at (p\p.east);
      }
      \begin{pgfonlayer}{background}
        \foreach \p in {1,...,4}{
          \node[pattern=crosshatch, pattern color=green!80!black,fit={(p\p)},inner sep=1.5ex] {};
          \node[fill=white, fit={(p\p)}] {};
        }
        \foreach \p in {1,3,5,7}{
          \fill[pattern=horizontal lines, pattern color=blue]
          (p\p.north east) -- (p\p.south west) -- (p\p.south east) -- cycle;
        }
        \foreach \p in {3,...,7}{
          \fill[pattern=vertical lines, pattern color=blue]
          (p\p.north east) -- (p\p.south west) -- (p\p.north west) -- cycle;
        }
      \end{pgfonlayer}

      \node[inner sep = 4ex] (theOrigin) at ([xshift=-3ex]p3.10) {};
      \foreach \p in {1,...,7} { % for each "other" validator
        \coordinate (ac\p') at ([xshift=17ex-\p ex]theOrigin|-p\p) ;
    }
    \node (ac3') at ([xshift=17ex-3 ex]theOrigin|-p3) {\ac\ensuremath{{}_3}};
    \draw[->] (theOrigin) -- ([xshift=4ex,yshift=4ex]ac3'); 
    \coordinate[right=14ex of ac3'] (sigAgg);
    \foreach \p in {1,2,4} { % for each "other" validator
      \node[fill=white] (av\p) at (sigAgg){\hd\makebox[0pt][l]{\ensuremath{{}_{\sim\p}}}};
      \coordinate (sigAgg) at ([xshift=-1ex,yshift=-1ex]sigAgg);
    }
    \foreach \p/\y in {1/2,2/1,4/-14} {
      \node[left=\y ex of ac\p',fill=white] (hd\p') {\hd};
      \draw[->] (hd\p') -- (av\p);
    }
    \begin{pgfonlayer}{background}
      
      \node[fit={(av4)([xshift=2ex]av1.north east)([xshift=-2ex]ac3'.west)},pattern=crosshatch,pattern color=green!80!black,draw] (bkGreen) {};
    \end{pgfonlayer}
    \foreach \p in {1,...,4} { % for each "green" validator
      \node[right=25 ex of ac\p'] (bkGreen\p') {\bk};
      \draw[->] (bkGreen) -- (bkGreen\p'); 
    }
    \foreach \p in {5,...,7} {
      \node[right=35 ex of ac\p',fill=white] (hd\p') {\hd};
      \draw[->] (hd\p') -- (ac\p');
    }
    \coordinate[right=15 ex of bkGreen3'] (sigAgg);
    \foreach \p in {7,...,5} { % for each "other" validator
      \node[fill=white] (av\p) at (sigAgg){\hd\makebox[0pt][l]{\ensuremath{{}_{\sim\p}}}};
      \draw[->] (hd\p') -- ([xshift=1ex,yshift=-.5ex]av\p.south east);
      \coordinate (sigAgg) at ([xshift=-1ex,yshift=-1ex]sigAgg);
    }
      \begin{pgfonlayer}{background}
        
        \node[fit={(bkGreen3')([xshift=2ex]av7.north east)(av5)},pattern=vertical lines,pattern color=blue,draw] (bkBlue) {};
      \end{pgfonlayer}
    \foreach \p in {7,...,3,1} { % for each validator in some "blue" quorum, 
      \node[right=65 ex of ac\p'] (bkBlue\p') {\bk[blue]\ensuremath{{}_3}};
      \draw[->] (bkBlue.east) -- (bkBlue\p'); 
    }
    \coordinate (top) at (bkBlue3'.east|-p1); 
    \coordinate (bottom) at (bkBlue3'.east|-p7); 
    \draw[double,very thick,dotted] ([xshift=1ex,yshift=1ex]top) -- ([xshift=1ex,yshift=-1ex]bottom);
    \coordinate (sigAgg) at ([xshift=20ex]bkBlue5');
    \foreach \p in {7,...,4} { % for each "other" blue validator, not 3
      \node[fill=white] (bk\p) at (sigAgg){\bk[blue]\makebox[0pt][l]{\ensuremath{{}_\p}}};
      %\draw[->] (bk\p') -- ([xshift=1ex,yshift=-.5ex]av\p.south east);
      \coordinate (sigAgg) at ([xshift=-1ex,yshift=-1ex]sigAgg);
      \draw[->] (sigAgg|-p\p) -- (bk\p.south east);
    }    
    \begin{pgfonlayer}{background}
      \node[fit={(bkBlue5')([xshift=2ex]bk7.north east)(bk4.south west)},fill=lightgray] (BlueBlocks) {};
    \end{pgfonlayer}
    \foreach \p in {3,5,6,7} {% for some blue learners
      \node[draw=blue] (qs\p) at ([xshift=5ex]BlueBlocks.east|-p\p) {\qs[5]};
      \draw (BlueBlocks.east) -- (qs\p);
    }
  \end{tikzpicture}%
    \todo{for cooler patternage
      \url{https://tex.stackexchange.com/questions/597172/tikz-set-the-line-width-of-the-pattern}
    }
  }
  \caption[Integrity protocol]{%
    The integrity protocol 
    (concluding each round that's was “opened” in the availability-protocol)%
  }
  % 
  \label{fig:integrity-protocol}
\end{figure}
\todo[caption={},inline]{%
  blue blocks are sent to all validators in 
  \begin{enumerate}
   \item[①] the signing quorum and
   \item[②] \textsc{any other} blue quorum 
   \end{enumerate}
}

\subsection{Availability: the typical case}

\begin{description}
\item[Generating and broadcasting signed quorums]
  \tnote{primary \\⇒ primary}
  Once a validator has collected 
  enough new  blocks (for a learner), 
  it signs a learner-specific quorum of such blocks;
  the result is called a \emph{signed quorum},  
  for short. 
  All these blocks have to be from the same round. {\color{red} important ‼}

  Under certain conditions,
  in particular if there is exceptional delay for a specific learner,
  one can forgoe announcing a proper signed quorum
  and instead signs a \emph{dummy quorum} for a specific learner,
  \ie a signature over the ID of the learner in question and the current round number.  

\item[General header compilation]
  The biggest additional work and data
  concerns the compilation of headers.
  In the typical phase, 
  a header carries two additional data items, namely
  \begin{itemize}
  \item 
    the availability certificate of the previous header 
    of the header's creator/initiator
  \item 
    hashes of the signed (dummy) quorums sent by the same validator
  \end{itemize}

\item[General header checking]
  As signed quorums also serve as certificates of availability,
  checking a signed quorum amounts to checking the signed certificates.\endnote{%
    Somehow it seems overkill to have (hases of) signed quorums in the headers.   }
  In a similar way,
  the certificate of availability amounts to a checking of signatures.
\end{description}

\todo[inline]{describe in detail how 

  the checking of the availability of the headers takes place}

\subsection{Summary}
The availability protocol in a non-genesis round 
only differs in having
\begin{enumerate}
\item the additional requirement 
that each block header also includes 
the certificate of availability 
for the previous header of the same validator and 
\item 
the sending and checking of signed quorums
(each of which implements the reference to 
blocks from the previous round—in a learner-specific \Dag).
\end{enumerate}

As a consequence,
casting an availability vote / sending a commitment message 
\todo{discuss terminnolgy}
becomes a recursive commitment
to storing all blocks until genesis 
(or the last block that some of learners might still want availabl). 

\section{Data structures}

\begin{figure}[htb]
  \centering
% \subfloat[\color{violet} \bf Missing]{
%   \begin{minipage}{.3\linewidth}
%       \begin{itemize}
%   \item Integrity Vote (cf. Availability Vote → Storing promise ?)
%   \item ~ 
%   \end{itemize}
%   \end{minipage}
% }

  \subfloat[Transaction received by worker~\(w\)]{
    \tx:
    \begin{tikzpicture}[baseline={([yshift=-.5ex]b.center)}]
      \node[ellipse,fill=black] (b){
        \textcolor{white}{\bf\footnotesize\begin{tabular}[c]{c}
                                            trasaction\\
          data
        \end{tabular}}
    };
    \node[anchor=west] (w) at (b.south east) {\small\({}\to w\)};
    \end{tikzpicture}
  }
  \qquad
  \subfloat[Transaction copy (trivial erasure share)]{
    \es: \tx
    % \begin{tikzpicture}[baseline={([yshift=-.5ex]b.center)}]
    %   \phantom{
    %   \node[ellipse,fill=black] (b){
    %     \textcolor{white}{\bf\footnotesize\begin{tabular}[c]{c}
    %       blob\\
    %       of\\
    %       data
    %     \end{tabular}}
    %   };}
    % % https://texample.net/tikz/examples/torn-paper/ 
    % % ‼ make cute torn edges
    % \clip[fill] ([xshift=-1em]b.north east)
    % -- ([yshift=1em]b.south west) 
    % -- ([xshift=1em]b.south west)
    % -- ([yshift=-1em]b.north east) -- cycle;
    % \node[ellipse,fill=black] (b){
    %     \textcolor{white}{\bf\footnotesize\begin{tabular}[c]{c}
    %       blob\\
    %       of\\
    %       data
    %     \end{tabular}}
    %   };
    % \end{tikzpicture}
}
  % \qquad
  % \subfloat[Worker \(y\) is commiting to the hash of~\(x\)]{
  %   \(y♯x\): \([\#(x)]_{\sim y}\)
  % }%‼

\subfloat[Batch hash of worker~\(w\)]{
  \#(\(\overrightarrow\tx\)):
  \#
    \(\left(\begin{tikzpicture}[baseline={(batch.center)}]
      \node[anchor=west] (batch) {
        \(\colorbox{lightgray}{\(\begin{array}[c]{c}
          {\tx}\\%_{\to w}
          {\tx}\\%_{\to w}
          {\tx}\\%_{\to w}
          {\tx}\\%_{\to w}
          {\tx}\\%_{\to w}
          {\tx}%_{\to w}
        \end{array}\)}\)
    };
      \end{tikzpicture}\right)\)
  }
  \subfloat[%
  Worker hash (issued by~\(w\)), 
  including the round number \(\rnd\),
  and the number of transactions~\(\|\protect\overrightarrow \tx\|\);
  it is signed by~\(w\)]{
    \wh:
    \begin{tabular}[t]{@{}l@{}}
      \begin{tikzpicture}[baseline={([yshift=-.5ex]wh.center)}]
        \node (wh){\(\left[ \#(\overrightarrow \tx), \rnd,  \|\overrightarrow \tx\| \right]_{w}\)}; 
      \end{tikzpicture}
      %\footnotesize
    % {\color{violet} + info for correctness checking} \\
    % (\eg number of \tx[s], or list of \#s)\\
    %   \emph{Tahoe – The Least-Authority Filesystem}
    \end{tabular}
  }

  \subfloat[Genesis Header]{
    \(\hd[]\):\(
\tikz[baseline={(x.base)}]{\node (x){
\(\left(p,\overrightarrow\wh\right)\)
};}\)
  }
\qquad
  \subfloat[Genesis certificate of availability]{
    \(\ac\): 
    \(\Bigl[\hd[]\Bigr]_{\overrightarrow q}\)
  }

  \subfloat[Block]{
\bk:
    \begin{math}
      \left[\hd\right]_{\color{green!60!black}{\sim p_1 \dots \sim p_m} [ \color{green!60!black}\sim p_{m+1} \cdots \sim p_{k}]}
    \end{math}
  }
  \qquad
  \subfloat[Signed quorum]{
    \(\qs_p\):
    \begin{math}
      \begin{array}[c]{@{\rhd}l}
        [\bk_1 \cdots \bk_\ell]_{\sim p}
      \end{array}
    \end{math}
  }

  \subfloat[Header]{
    \(\hd\):\(
\tikz[baseline={(x.base)}]{\node (x){
\(\left(p,\overrightarrow\wh,\ac, \overrightarrow {\#(\qsₚ)}\right)\)
};}\)
  }


  \caption{Overview of data structures}
  \label{fig:data-structures}

\end{figure}
\FloatBarrier






\section{Message dependency management}

Messages depending on other messages
is a \emph{sine qua non} of consensus protocols.
In \hn,
we have several types of dependencies.

\begin{ex}[Answering header signature requests]
  Header signature requests (in the availability protocol)
  can only be answered (correctly) by a validator if
  it has received a confirmation from each of its workers.\footnote{
    Each confirmation states that
    a copy of the hash-referenced transaction data has been stored.
  }
  This scenario is simple in that
  \begin{itemize}
  \item one knows exactly which messages are expected;
  \item each expected message's \emph{fingerprint} is known in advance;
  \item there is only a single message to be synthesized;
  \item progress towards meeting all requirements is monotonic.
  \end{itemize}
  Hence, there is a conceptually simple data structure
  where each arriving message is mapped to a pair of
  a (shared) counter and a pointer to the message to be signed. 
\end{ex}

The next example is more tricky in that
we are interested only in the first \(k\) messages out of \(n\). 

\begin{ex}[Broadcasting certificates of availability (\textsc{i/ii})]
  
\end{ex}

\begin{verbatim}
{
from [37] L. Zheng. Making distributed computation secure by construction. PhD thesis,
Cornell University, Ithaca, New York, USA, Jan. 2007.
}

4.4 Replication and message synthesis

Replicating code and data is an effective way to achieve 
fault tolerance and ensure integrity and availability. 
In DSR, both reactors and memory references may be replicated
on multiple hosts. Suppose reactor c is replicated on a set of hosts H. 
Then other reactors interact with c as follows:
• Any message for c is sent to all the hosts in H.
• The replicas of c process incoming messages independently of each other. To
make this possible, all the program states of c have a local copy on every host in H.
In particular, every memory reference (location) accessed by c is also replicated
on H.
• If invoked with the same context identifier, the replicas of c are supposed to pro-
duce the same messages. Thus, the receiver host h of such a message µ may
receive the replicas of µ from different hosts in H. The redundancy is crucial
for achieving fault tolerance. Some hosts in H may be compromised, and these
bad hosts may send corrupted messages or simply not send anything. In general,
the replicas of µ received by h contain some correct ones, which are the same,
and some bad ones, which can be arbitrarily inconsistent. It is up to h to identify
the correct µ from those message replicas. This process is called message syn-
thesis, and the algorithm for identifying the correct message is called a message
synthesizer.
\end{verbatim}
\begin{verbatim}
message synthesizer ref(s)
  [37] L. Zheng. Making distributed computation secure by construction. PhD thesis,
  Cornell University, Ithaca, New York, USA, Jan. 2007.


  [39] L. Zheng and A. C. Myers. A language-based approach to secure quorum replication.
  In Proceedings of the Ninth Workshop on Programming Languages and Analysis for
  Security, PLAS’14, pages 27:27–27:39, New York, NY, USA, 2014. ACM. ISBN
  978-1-4503-2862-3. . URL http://doi.acm.org/10.1145/2637113.2637117.
\end{verbatim}

\bibliographystyle{alpha}
\bibliography{HN.bib}


\appendix

\section{Endnotes}
\printendnotes
\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-engine: luatex
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
